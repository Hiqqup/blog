---
title: 'Cross-platform Hello Triangle'
description: 'Building a cross-platform game engine, using c++, OpenGl, glfw, emscripten.'
pubDate: 'Nov 22 2025'
heroImage: '../../assets/hello-textured-rectangle.png'
---

### Motivation

The uni project I will attend next year (Game Lab 3), requires us to build our own game engine using low level technologies.
The tech stack proposed is:

<div class="table-with-borders" >


| Core          | Auxiliary |
|---------------|-----------|
| C++           | glm       |
| OpenGL (glad) | tinyGLTF  |
| GLFW          | soloud    |

</div>


I am not 100% going to stick to these libraries, for instance I hope next year I will already be using the industry standard API Vulkan.
Until then, I will have to do a lot of learning, for which OpenGl is a better starting point.

### Why cross-platform?

Another point where I will not 100% stick to the project guidelines is the target platform. We should develop our game
mainly for Windows. Firstly I don't use any Windows machines so that might be a challenge.

Next developing for any one
platform requires players to download the game before playing it. This isn't great especially for small projects you
don't know you are going to enjoy or that you don't trust. So I want my game to be in the browser so it is as accessible
to everyone as possible.

### How to achieve cross-platform?

[GLFW](https://www.glfw.org/) already supports a lot of platforms, such as Linux, Windows and macOS.
But how are we going to achieve browser-compatibility using the proposed tech stack?

In comes [Emscripten](https://emscripten.org/), a toolchain for building C/C++ programms to WebAssembly. Let's see this in action.

### Hello triangle example no abstractions

If you are not familiar with, how a programm that renders is structured, I advise you checkout [learn OpenGl](https://learnopengl.com).
It is a great resource for all things OpenGl, you can find the code we will be referencing [here](https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp).

For emscripten it is a little harder to find a hello triangle example, so I'll propose this one to get us up and running:
``` cpp
// main.cpp
#include <emscripten/emscripten.h>
#include <emscripten/html5.h>
#include <GLES3/gl3.h>
#include <iostream>

GLuint shaderProgram;
GLuint VAO;

const char* vertexShaderSource =
R"(#version 300 es
    layout(location = 0) in vec3 aPos;

    void main() {
        gl_Position = vec4(aPos, 1.0);
    }
)";
const char* fragmentShaderSource =
R"(#version 300 es
    precision mediump float;
    out vec4 FragColor;
    void main() {
        FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);;
    }
)";

void updateViewport() {
    double width, height;
    emscripten_get_element_css_size("#canvas", &width, &height);
    emscripten_set_canvas_element_size("#canvas", (int)width, (int)height);
    glViewport(0, 0, (int)width, (int)height);
}
void initGL(){
    EmscriptenWebGLContextAttributes attr;
    emscripten_webgl_init_context_attributes(&attr);
    attr.alpha = false;
    attr.depth = true;
    attr.stencil = false;
    attr.antialias = false;
    attr.majorVersion = 2;
    attr.minorVersion = 0;
    EMSCRIPTEN_WEBGL_CONTEXT_HANDLE ctx =
        emscripten_webgl_create_context("#canvas", &attr);

    if (ctx <= 0) {
        std::cerr << "Failed to create WebGL2 context\n";
        return;
    }

    emscripten_webgl_make_context_current(ctx);

    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, nullptr);
    glCompileShader(vertexShader);

    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, nullptr);
    glCompileShader(fragmentShader);

    shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    float vertices[] = {
        // positions
         0.0f,  0.5f, 0.0f,
        -0.5f, -0.5f, 0.0f,
         0.5f, -0.5f, 0.0f,
    };

    GLuint VBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);

    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);


    glBindVertexArray(0);

}

void render(){
    updateViewport();
    glViewport(0, 0, 800, 600);
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glUseProgram(shaderProgram);
    glBindVertexArray(VAO);
    glDrawArrays(GL_TRIANGLES, 0, 3);
}

int main(){
    initGL();
    emscripten_set_main_loop(render, 0, true);
    return 0;
}
```
As well as some html glue:
``` html
<!-- Index.html -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hello Triangle - WebGL2</title>
  <style>
    body, html { margin: 0; padding: 0; }
    canvas { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script src="hello_triangle.js"></script>
</body>
</html>
```
Compile with:
```sh
emcc main.cpp -o hello_triangle.js\
    -sUSE_WEBGL2=1\
    -sFULL_ES3=1\
    -sALLOW_MEMORY_GROWTH=1\
    -sASSERTIONS=1
```
And run with:
```sh
emrun --port 8080 .
```

### Combining the examples into one project

Let's introduce a common interface around the two:
``` cpp
class IBackend {
public:
    virtual void init() = 0;
    virtual void do_main_loop() = 0;
    virtual void cleanup() = 0;
};

class DesktopBackend: public IBackend;
class BrowserBackend: public IBackend;
```

For now, we are not going to make any major abstractions just copy the main stages of the examples into each of the methods.
This allows us to only have one check in main for which platform we are building for using a preprocessor statement.
``` cpp
int main() {
    #ifdef __EMSCRIPTEN__
    BrowserBackend b;
    #else
    DesktopBackend b;
    #endif
    b->init();
    b->do_main_loop();
    b->cleanup();
    return 0;
}
```
Next we are going to introduce a build-system: [Cmake](https://cmake.org/).

``` cmake
# introduce an option to check for what we are building
option(BROWSER_BUILD "Building for browser or not" OFF)

set(SOURCES main.cpp IBackend.h )
set(DEPENDENCIES)

if(BROWSER_BUILD)
    list(APPEND SOURCES BrowserBackend.cpp BrowserBackend.h )
    # copying over the html shell
    set(CMAKE_EXECUTABLE_SUFFIX ".js")
    configure_file(${CMAKE_SOURCE_DIR}/index.html ${CMAKE_BINARY_DIR}/index.html COPYONLY)
else()
    list(APPEND SOURCES DesktopBackend.cpp DesktopBackend.h )
    # fechting some dependencies here ...
    list(APPEND DEPENDENCIES glad glfw )
endif()

add_executable(${EXE_FILE} ${SOURCES} )
target_link_libraries(${EXE_FILE} PRIVATE ${DEPENDENCIES})

if(BROWSER_BUILD)
    # and don't forget to add in the flag here
    set(MY_FLAGS
    "-sUSE_WEBGL2=1"
    "-sFULL_ES3=1"
    "-sALLOW_MEMORY_GROWTH=1"
    "-sASSERTIONS=1"
    )
    target_compile_options(${EXE_FILE} PRIVATE ${MY_FLAGS} )
    target_link_options(${EXE_FILE} PRIVATE ${MY_FLAGS} )
endif()
```

With this system in place we can focus on abstracting out the similarities across th examples.

### Abstracting the OpenGl version

As the examples currently stand we have different versions of Open Gl in our desktop and browser code. In order for us to
find an Abstraction among the two we will need to find a standard both versions support.

Introducing **OpenGL ES 3.0**. This is the standard supported by WebGL 2 and gives us a recent graphics API that is supported on both platforms.
Our Emscripten browser example is already using **OpenGL ES 3.0** so we dont need to change anything about it.

For our desktop version we need to change the version of the shader to ``` #version 300 es``` and supply glfw with a new
window hint:
- ``` glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);```
- ``` glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);```


With the same GL version in place, we can extract out all the GL calls to the backend interface (
I know interfaces shouldn't normally have code but we'll use this as a temporary stepping stone on our way to a uniform interace).
When doing this you will run into the problem on not having clear insight which header the GL functions shall come from.
We can get around this by declaring another header ```gl_backend.h``` which using another preprocessor includes the respective header.

``` cpp
#pragma once
#ifdef __EMSCRIPTEN__
    #include <GLES3/gl3.h>
#else
    #include <glad/glad.h>
#endif
```

### Abstracting the windowing code

Currently, our Emscripten example is using the Emscripten custom API to choose the context. In order to further
simplify our code we can have Emscripten use glfw as well, but careful: this comes with drawbacks. The support for
glfw isn't officially considered stable and some features like multiple windows are not supported so handle with caution.

I chose to go that route anyway, because it is going to save some complexity when it comes to input handling down the line.
We will need to include the ```-sUSE_GLFW=3``` flag for our compilation step. Besides that the only real difference between the
browser and desktop versions is the loading of glad and the way the main loop is handled.

Now you might run into another problem: How can the content of the main-loop get access to the variables it needs to process.
For this we are going to use a lambda: ``` const std::function<void()>& main_loop_callback)``` and for the browser side
```emscripten_set_main_loop_arg()```

### Asset Loading
At some stage in our game we will need separate asset files for shaders, textures, etc. This is were another quirk of
Emscripten comes into play. Of course for both platforms we will need cmake to copy over the assets:

``` add_custom_target(copy_assets COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_SOURCE_DIR}/assets $<TARGET_FILE_DIR:${EXE_FILE}>/assets )```

But additionally we will need emscripten to load the files. There are different ways to do this. Embedding, Fetching at Runtime,
but for now we are going to focus on preloading the assets.

The flag we need to add in order to do this is ``` "${CMAKE_CURRENT_SOURCE_DIR}/assets/@/assets" ```
And in order to fetch the assets in our game we can access them from ```/assets/...``` unlike on the desktop where you would use something like:
```  std::filesystem::canonical(path);```

### Concluding Remarks

While it takes some setup and might seem complicated at first, I think that it is really cool that you can write exactly
the same c++ code for browser and for desktop when developing a game, and this at such a low level where you are even interfacing
a graphics API. You can find the code at the stage presented in this blog [here](https://github.com/Hiqqup/cross_platform_game_engine/commit/1d5706301280a4d0bf35ebba4ac0a02f6c580184). I left out some details when it
comes to configuring your editor environment to support your cross-platform development endeavors.

I might feature them in future posts. Till then stay curious :^)